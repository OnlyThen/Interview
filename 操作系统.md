# 进程、线程
## 概念、联系、区别
* 进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中操作系统分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，至少有5种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。
* 线程是CPU调度和执行的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。运行期、挂起、死亡、正常退出、和线程阻塞
* 线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
* 在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），优先级，线程之间切换的开销小。
* 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。
* 内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。
* 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

## 产生原因
计算机操作系统里面有两个重要概念：并发和隔离。 
并发是为了尽量让硬件利用率高，线程是为了在系统层面做到并发。线程上下文切换效率比进程上下文切换会高很多，这样可以提高并发效率。

隔离也是并发之后要解决的重要问题，计算机的资源一般是共享的，隔离要能保障崩溃了这些资源能够被回收，不影响其他代码的使用。所以说一个操作系统只有线程没有进程也是可以的，只是这样的系统会经常崩溃而已，操作系统刚开始发展的时候和这种情形很像。

##进程上下文切换开销
直接开销就是在切换时，cpu必须做的事情，包括：
* 切换页表全局目录
* 切换内核态堆栈
* 切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）
* 刷新TLB
* 系统调度器的代码执行
间接开销主要指的是虽然切换到一个新进程后，由于各种缓存并不热，速度运行会慢一些。如果进程始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。

## 地址空间
又称用户空间，每个进程有各自的私有用户空间，这个空间对系统中的其他进程是不可见的，一个程序编译连接后形成的地址空间是一个虚拟地址空间，但是程序最终还是要运行在物理内存中。因此，应用程序所给出的任何虚地址最终必须被转化为物理地址，所以，虚拟地址空间必须被映射到物理内存空间中，这个映射关系需要通过硬件体系结构所规定的数据结构来建立。这就是我们所说的段描述符表和页表，Linux主要通过页表来进行映射。

逻辑地址->段寻址->线性地址（虚拟地址）->页寻址->物理地址
* 编译器编译程序时，会为程序生成代码段和数据段，然后将所有代码放到代码段中，将所有数据放到数据段中。最后程序中的每句代码和每条数据都会有自己的逻辑地址。
* CPU加载程序后，会为这个程序分配内存，所分配内存又分为代码段内存和数据段内存。代码段内存的基址保存在CS中，数据段内存的基址保存在DS中。
* 由于线性地址是连续，内存中可能没有这么大的一块连续空间。为了解决这个问题，CPU采用了分页的内存管理机制。
* 在`Intel`平台下，逻辑地址(logical address)是 selector:offset 这种形式，selector 是 CS 寄存器的值，offset 是 EIP 寄存器的值。如果用 selector 去 GDT( 全局描述符表 ) 里拿到 segment base address(段基址) 然后加上 offset(段内偏移)，这就得到了 linear address。我们把这个过程称作段式内存管理。
* 如果再把 linear address 切成四段，用前三段分别作为索引去PGD(Page Global Directory)、PMD(Page Middle Directory)、Page Table里查表，最终就会得到一个页表项(Page Table Entry)，那里面的值就是一页物理内存的起始地址，把它加上 linear address 切分之后第四段的内容(又叫页内偏移)就得到了最终的 physical address。我们把这个过程称作页式内存管理。

内核空间   |  1GB
--------- | --------
          |
栈        | 用于维护函数调用的上下文
          |
共享库和mmap内存映射区 |
          |
堆        |
          |
BSS 段    | Block Started by Symbol
Data 段   | 初始化数据段
Text 段   | 代码段中存放可执行的指令
          |
          
* Text段包含了可执行程序（二进制）；
* Data段存储已初始化的全局变量、静态变量、局部静态变量，分为仅读区、可读可写区；
* BSS段存储未初始化的全局变量；
* 堆存储动态分配的内存中的数据，向上增长；
* 比如很多程序都会用到的printf，函数共享库 printf.o 固定在某个物理内存位置上，让许多进程映射共享。mmap是个系统函数，可以把磁盘文件的一部分直接映射到内存，这样文件中的位置直接就有对应的内存地址，对文件的读写可以直接用指针来做而不需要read/write函数。
* 栈用于保存局部变量和实现函数/过程调用的上下文，它们的大小都是会在进程运行过程中发生变化的，向下增长。

## 异步、同步

## 用户态、内核态
操作系统对执行权限进行分级，分别为用户态和内核态。用户态相较于内核态有较低的执行权限，很多操作是不被操作系统允许的，内核态相当于一个介于硬件与应用之间的层，内核有ring 0的权限，可以执行任何cpu指令，也可以引用任何内存地址，包括外围设备, 例如硬盘, 网卡，权限等级最高。

1. 系统调用
2. 异常
3. 中断


